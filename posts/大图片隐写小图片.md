---
title: 大图片隐写小图片
date: 2020-03-19 14:54:06
categories: 课内的奇奇怪怪
tags:
  - 信息隐藏
  - 隐写
  - Python
abbrlink: 2003190
cover:
---
# 大图片隐写小图片实现

注：如果出现 KB，MB 这种单位，都是指 1 MB = 1024 KB, 1 KB = 1024 Byte, 1 Byte = 8 bit
## 分析
一张图片由许多像素点组成，常见的矩形图像，长和宽的乘积确定了图像的像素点个数，每个像素点有一个颜色，表示颜色又有很多方案，以常见的 rgb 方案为例，则一张 512×512 的图片应有 512×512×3 字节（未压缩）的数据用于存放颜色。如果是灰度图，则只有 512×512×1 字节（未压缩）用于存放颜色。

rgb 的三位，因为范围在 0-255，所以每位只需一个字节（8bit）来存放。而已知一张图片，如果将其每个像素点的 rgb 三个字节每个字节最后 1 bit 置 0，用肉眼是看不出和原图的区别的（最后 1 bit 置 0 最多使原值减少 1,故差别不大~~，50%不变，50%减小1~~）。经过实际测试，每字节最后 2 bit 置 0 也看不出区别（因为最多减少 3）。有了这个前置条件，就意味着每个像素点都可以抽出 3 bit 的空间（6 bit 也可以~~，够狠的话 9 bit 也可以，图像只比原图暗了一点点，但推荐还是 8 bit，凑个整~~）用于隐藏其他信息。
### 不同掩码效果测试

1. 原图![lenna.png](/blog/pics/1584418501039-2a404d04-2062-46a4-a4cb-acfd503f7faf.png)
1. 0xFE![0xFE.png](/blog/pics/1584418605916-c62e7cd7-e9fd-41d2-afc5-beaf317e2fc6.png)
1. 0xFC![0xFC.png](/blog/pics/1584418616505-21fd8db1-61e6-4c7a-8e1f-7a7873fd1d1d.png)
1. 0xF8![0xF8.png](/blog/pics/1584418638759-6cdf3161-8f09-4c64-96dc-a75d0584a4b1.png)
1. 0xF0![0xF0.png](/blog/pics/1584418657041-d6fb5c54-e0de-4957-8bac-f80c1cff70c9.png)
1. 0xE0![0xE0.png](/blog/pics/1584418687223-3f5adf66-5552-4793-b5af-d9f501e6af78.png)
1. 0xC0![0xC0.png](/blog/pics/1584418694122-011c55b8-5473-4249-91c9-78aad32010a9.png)
### 隐藏二进制流
这就没有任何要求，只要有空间，往里放就行。每个像素点隐藏 3 bit，则一张 512×512 的图片可以隐藏 512×512×3 bit 即 96 KB 的二进制信息。
### 隐藏黑白（只有纯黑纯白的那种）图片
每个像素点只需要 1bit 位来隐藏，所以一张彩色图片只需要在 rgb 三位里挑一种颜色的最后一 bit 置零用于隐藏信息，就可以隐藏和载体一样尺寸的黑白图片了。（这有啥用？当然有用，比如二维码）
### 隐藏灰度图片
因为灰度图片每个像素点只用一个字节来存放颜色深浅程度，故一张 512×512 的灰度图只需要隐藏 512×512×1×8 bit 的信息，而一张 512×512 的图片只有 512×512×3 bit 的空间用于隐藏其他信息（~~当然如果按前面说的每像素点 rgb 三位共抽出 8bit，这样就可以刚好隐藏一张相同尺寸的灰度图~~）。（~~灰图并不是我讨论的重点，自己玩去~~）
### 隐藏 rgb 图片
对于一张 512×512 的 rgb 图片，需要 512×512×3×8 bit 的空间才能隐藏。即 768 KB。**但实际观察发现，一张 512×512 的图片并没有 768 KB，因为经过了压缩。所以其实把一张图片当作二进制流来隐藏，效率是比隐藏原始颜色数据要高的（应该是这样，我单方面觉得）（当然如果颜色足够杂乱，压缩的效率大幅降低，这时当作二进制流可能会比存原始颜色数据要大）**。

按原始颜色隐藏

- 如果载体图片**每个像素点只取 1bit **用于隐藏私密信息，而私密图片每个像素点有 3×8 bit 的信息需要被隐藏，所以需要载体的尺寸（指长宽乘积，即像素点个数）需要是私密图片尺寸（同上）的 **24 倍**。
- 如果载体图片**每个像素点取 3 bit **用于隐藏私密信息，即每字节隐藏 1bit，所以**隐藏效率是 1/8**，需要载体尺寸是私密图片的** 8 倍**。
- 如果载体图片**每个像素点取 6 bit **用于隐藏信息，即每字节隐藏 2 bit，所以**隐藏效率是 1/4**，需要载体尺寸是私密图片的 4 倍。而恰好 4 是可以开平方的，长宽乘 2 就可以。（所以我的实现应该会采用这种方式）

按二进制流隐藏，当压缩效率还行的时候，比如经典的 Lenna 图片，我下载了 512×512 尺寸的彩色图（提供一下 SHA256，以明确到底说的是哪张图片，SHA256: 7e497501a28bcf9a353ccadf6eb9216bf098ac32888fb542fb9bfe71d486761f），大小是 473831 Byte，即 3790648 bit。

- 如果载体图片每个像素点取 1 bit 用于隐藏，而且假设载体宽 512 px，则 3790648 / 512 = 7403.6，所以载体长度需要至少 7404 px
- 如果载体图片每个像素点取 3 bit，则需要 2467.8 即 2468 px
- 如果载体图片每个像素点取 6 bit，则需要 1233.9 即 1234 px，隐藏效率（按尺寸来算）大概是 41.5%，即相同宽度只能隐藏长度为载体长度 41.5% 的图片。
### 结论
所以我在作业里说可以通过编码来提高隐藏效率（这里的编码当然是指压缩），最终实现隐藏同样尺寸甚至更大尺寸（稍微大一点）似乎是实现不了的？~~并不，我还有招~~。
### 脑洞拓展（并不脑洞，完全可行）
既然载体图可以每字节抽 2bit 出来用于隐藏私密信息，并且用肉眼看不出微小的差别。那么隐藏的私密图片，难道就不能有略微损耗吗？如果我私密图片每一字节，也只要前 6 bit，最后 2 bit 我不要了，这样和原图的差别用肉眼也很难看出，但是隐藏效率会提升很多，不妨计算一下。（**当然这种情况只适用于压缩效率不高的图片，压缩效率高直接作为二进制就很高效了，而二进制数据是不能有差错的，不然无法解码**）

每 8 bit 只隐藏 6 bit，这样就减少了 25% 的负担。

好吧，确实载体需要比私密私密图片大（指像素尺寸）。毕竟有信息论摆在那，我搁这找啥没趣呢。如果需要载体和私密图片相同尺寸，**折中的方案是载体的 8 bit 只取前 4 bit，后 4 bit 用于隐藏信息，而私密图片的 8 bit 也只取前 4 bit存放在载体的后 4 bit，私密图片的后 4 bit 抛弃**。这样的话图片质量非常差，参见掩码 0xF0。这种方案就可以使载体尺寸和隐藏图片的尺寸相同，且符合信息论规律。
## 具体实现（Python3 版本，Matlab 请饶步）
### 依赖库及安装

- opencv2

`pip3 install opencv-python`

- numpy

`pip3 install numpy`
### 代码
```python
#!/usr/bin/python3
import sys
import cv2
import numpy as np

errors = [ "everything is ok", "carrier image too small", "size is just right, don't be so coincident next time" ]

def enc(carrier_path, secret_path, output_path):
    carrier = cv2.imread(carrier_path)
    carrier_height, carrier_width = carrier.shape[:2]

    secret = cv2.imread(secret_path)
    secret_height, secret_width = secret.shape[:2]

    secret_pixel_num = secret_height * secret_width

    # check
    if carrier_height * carrier_width < 4 * secret_pixel_num:
        return 1

    # # pre
    # for i in range(carrier_height):
    #     for j in range(carrier_width):
    #         for k in range(3):
    #             carrier[i, j, k] &= 0xFC

    # process
    offsets = [ 6, 4, 2, 0 ]
    for i in range(carrier_height):
        print("%2.1f%% process" % (i*100 / carrier_height), end="\r")
        for j in range(carrier_width):
            linear_index = i * carrier_width + j
            quotient, remainder = linear_index // secret_pixel_num, linear_index % secret_pixel_num
            if quotient >= 4:
                cv2.imwrite(output_path, carrier)
                return 0
            secret_i, secret_j = remainder // secret_width, remainder % secret_width
            for k in range(3):
                carrier[i, j, k] &= 0xFC
                carrier[i, j, k] ^= 0x03 & (secret[secret_i, secret_j, k] >> offsets[quotient])
    cv2.imwrite(output_path, carrier)
    return 2

def dec(carrier_path, output_path):
    carrier = cv2.imread(carrier_path)
    carrier_height, carrier_width = carrier.shape[:2]

    # TODO: support more, like read from mixed file
    secret_height, secret_width = 512, 512
    secret_pixel_num = secret_height * secret_width
    secret = np.zeros((secret_height, secret_width, 3), np.uint8)

    # check
    if carrier_height * carrier_width < 4 * secret_pixel_num:
        return 1

    # # pre
    # for i in range(carrier_height):
    #     for j in range(carrier_width):
    #         for k in range(3):
    #             carrier[i, j, k] &= 0xFC

    # process
    offsets = [ 6, 4, 2, 0 ]
    for i in range(carrier_height):
        print("%2.1f%% process" % (i*100 / carrier_height), end="\r")
        for j in range(carrier_width):
            linear_index = i * carrier_width + j
            quotient, remainder = linear_index // secret_pixel_num, linear_index % secret_pixel_num
            if quotient >= 4:
                cv2.imwrite(output_path, secret)
                return 0
            secret_i, secret_j = remainder // secret_width, remainder % secret_width
            for k in range(3):
                secret[secret_i, secret_j, k] ^= (carrier[i, j, k] & 0x03) << offsets[quotient]
    cv2.imwrite(output_path, secret)
    return 2

if __name__ == "__main__":
    exit_code = 0

    if len(sys.argv) == 3:
        exit_code = dec(sys.argv[1], sys.argv[2])
    elif len(sys.argv) == 4:
        exit_code = enc(sys.argv[1], sys.argv[2], sys.argv[3])
    else:
        print("[Usage]:")
        print("    Encrypt:", sys.argv[0], "[carrier] [secret] [output]")
        print("    Decrypt:", sys.argv[0], "[carrier] [output]")

    if exit_code != 0:
        print("[Error]:", errors[exit_code])

```
### 测试结果

1. 载体图片![carrier.png](/blog/pics/1584434328061-d2033bd4-45a7-4398-9812-c92bf8548fbe.png)
1. 需隐藏的图片：标准 Lenna 图
1. mixed.png![mixed.png](/blog/pics/1584434447678-6e4c3815-a537-4aa4-b137-c656bcbb8807.png)
1. 解出 out.png![out.png](/blog/pics/1584434701290-77a5dbab-327b-42e9-8b18-58dd3bd727a0.png)
### 问题

- 本来觉得取 2bit 应该不会有问题，实现了才发现其实是看得出来的，mixed.png 这张仔细看左上角可以看出 Lena 的影子。但这个问题是可以解决的，因为我在算法实现时，按顺序去隐藏的，所以这样在左上角可以看到原图的影子。如果换个其他的顺序就可以解决。
- 解出原图的时候，是手动指定秘密图片尺寸的，这一点需要改进。应该在存的时候就把图片尺寸也编码进去，而不是在解的时候指定。

